/*
 * This file was generated by micropython-extmod-generator https://github.com/prusnak/micropython-extmod-generator
 * from Python stab file D:\microPython\micropython-extmod-generator\example\consts\consts.py
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2022 
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*
A MODULE COMMENT
*/

#define MODULE_CONSTS_ENABLED (1) // you may relocate this line to the mpconfigport.h
#if MODULE_CONSTS_ENABLED

// Include required definitions first.
#include "py/obj.h"
#include "py/objstr.h"
#include "py/objtuple.h"
#include "py/runtime.h"
#include "py/builtin.h"

#include "objfloat.h"

    /*
    // Example exception for any generated function
    if (some_val == 0) {
        mp_raise_ValueError("'some_val' can't be zero!");
    }
    */

/*
// Module constants declarations
STATIC const bool *CONST_FALSE = MP_ROM_FALSE;
STATIC const MP_DEFINE_FLOAT_OBJ(CONST_FLOAT_float_obj, 123.123);
STATIC const mp_int_t CONST_INT = 123;
STATIC const void *CONST_NONE = MP_ROM_NONE;
STATIC const MP_DEFINE_STR_OBJ(CONST_STR_str_obj, "QWERTY");
STATIC const bool *CONST_TRUE = MP_ROM_TRUE;

const mp_rom_obj_tuple_t CONST_TUPLE_1_1_tuple_obj = {{&mp_type_tuple}, 3, {
    MP_ROM_INT(10),
    MP_ROM_INT(20),
    MP_ROM_INT(30),
},};

const mp_rom_obj_tuple_t CONST_TUPLE_2_1_tuple_obj = {{&mp_type_tuple}, 3, {
    MP_ROM_INT(10),
    MP_ROM_INT(20),
    MP_ROM_INT(30),
},};
STATIC const MP_DEFINE_STR_OBJ(CONST_TUPLE_1_2_str_obj, "asdfg");
const mp_rom_obj_tuple_t CONST_TUPLE_1_9_tuple_obj = {{&mp_type_tuple}, 3, {
    MP_ROM_INT(1),
    MP_ROM_PTR(&CONST_TUPLE_2_1_tuple_obj),
    MP_ROM_PTR(&CONST_TUPLE_1_2_str_obj),
},};
STATIC const MP_DEFINE_STR_OBJ(CONST_TUPLE_0_2_str_obj, "asdfg");
STATIC const MP_DEFINE_FLOAT_OBJ(CONST_TUPLE_0_7_float_obj, 123.456);
STATIC const MP_DEFINE_STR_OBJ(CONST_TUPLE_0_8_str_obj, "QWERTY");
const mp_rom_obj_tuple_t CONST_TUPLE_0_6_tuple_obj = {{&mp_type_tuple}, 10, {
    MP_ROM_INT(1),
    MP_ROM_PTR(&CONST_TUPLE_1_1_tuple_obj),
    MP_ROM_PTR(&CONST_TUPLE_0_2_str_obj),
    MP_ROM_NONE,
    MP_ROM_TRUE,
    MP_ROM_FALSE,
    MP_ROM_FALSE,
    MP_ROM_PTR(&CONST_TUPLE_0_7_float_obj),
    MP_ROM_PTR(&CONST_TUPLE_0_8_str_obj),
    MP_ROM_PTR(&CONST_TUPLE_1_9_tuple_obj),
},};

*/

// Defining module functions
// def test_test()
STATIC mp_obj_t consts_test_test(void) {

	//TODO: Your code here

	return MP_ROM_NONE;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_0(consts_test_test_obj, consts_test_test);

// Defining classes
// class WithConsts(object):
/*
A CLASS COMMENT
*/
// WithConsts constants
STATIC const bool *WithConsts_CONST_FALSE = MP_ROM_FALSE;
STATIC const MP_DEFINE_FLOAT_OBJ(WithConsts_CONST_FLOAT_float_obj, 123.123);
STATIC const mp_int_t WithConsts_CONST_INT = 123;
STATIC const void *WithConsts_CONST_NONE = MP_ROM_NONE;
STATIC const MP_DEFINE_STR_OBJ(WithConsts_CONST_STR_str_obj, "QWERTY");
STATIC const bool *WithConsts_CONST_TRUE = MP_ROM_TRUE;

const mp_rom_obj_tuple_t WithConsts_CONST_TUPLE_1_1_tuple_obj = {{&mp_type_tuple}, 3, {
    MP_ROM_INT(10),
    MP_ROM_INT(20),
    MP_ROM_INT(30),
},};

const mp_rom_obj_tuple_t WithConsts_CONST_TUPLE_2_1_tuple_obj = {{&mp_type_tuple}, 3, {
    MP_ROM_INT(10),
    MP_ROM_INT(20),
    MP_ROM_INT(30),
},};
STATIC const MP_DEFINE_STR_OBJ(WithConsts_CONST_TUPLE_1_2_str_obj, "asdfg");
const mp_rom_obj_tuple_t WithConsts_CONST_TUPLE_1_9_tuple_obj = {{&mp_type_tuple}, 3, {
    MP_ROM_INT(1),
    MP_ROM_PTR(&WithConsts_CONST_TUPLE_2_1_tuple_obj),
    MP_ROM_PTR(&WithConsts_CONST_TUPLE_1_2_str_obj),
},};
STATIC const MP_DEFINE_STR_OBJ(WithConsts_CONST_TUPLE_0_2_str_obj, "asdfg");
STATIC const MP_DEFINE_FLOAT_OBJ(WithConsts_CONST_TUPLE_0_7_float_obj, 123.456);
STATIC const MP_DEFINE_STR_OBJ(WithConsts_CONST_TUPLE_0_8_str_obj, "QWERTY");
const mp_rom_obj_tuple_t WithConsts_CONST_TUPLE_0_6_tuple_obj = {{&mp_type_tuple}, 10, {
    MP_ROM_INT(1),
    MP_ROM_PTR(&WithConsts_CONST_TUPLE_1_1_tuple_obj),
    MP_ROM_PTR(&WithConsts_CONST_TUPLE_0_2_str_obj),
    MP_ROM_NONE,
    MP_ROM_TRUE,
    MP_ROM_FALSE,
    MP_ROM_FALSE,
    MP_ROM_PTR(&WithConsts_CONST_TUPLE_0_7_float_obj),
    MP_ROM_PTR(&WithConsts_CONST_TUPLE_0_8_str_obj),
    MP_ROM_PTR(&WithConsts_CONST_TUPLE_1_9_tuple_obj),
},};


STATIC const mp_obj_type_t consts_WithConsts_type;

typedef struct _mp_obj_consts_WithConsts_t {
    mp_obj_base_t base;
} mp_obj_consts_WithConsts_t;

// Defining WithConsts methods
// def WithConsts.test_test(self)
STATIC mp_obj_t consts_WithConsts_test_test(mp_obj_t self_obj) {
	mp_obj_consts_WithConsts_t *self = MP_OBJ_TO_PTR(self_obj);


	//TODO: Your code here

	return MP_ROM_NONE;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(consts_WithConsts_test_test_obj, consts_WithConsts_test_test);

// WithConsts stuff
// Register class methods
STATIC const mp_rom_map_elem_t consts_WithConsts_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_test_test), MP_ROM_PTR(&consts_WithConsts_test_test_obj) },
    #define USE_VALUE_WithConsts  // Use VALUE from the Python stab code or NAME(aka #define NAME) from include files when this line is commented out
    #ifdef USE_VALUE_WithConsts 
    { MP_ROM_QSTR(MP_QSTR_CONST_FALSE), MP_ROM_FALSE },
    #else
    { MP_ROM_QSTR(MP_QSTR_CONST_FALSE), MP_ROM_INT(CONST_FALSE) },
    #endif
    { MP_ROM_QSTR(MP_QSTR_CONST_FLOAT), MP_ROM_PTR(&WithConsts_CONST_FLOAT_float_obj) },
    #ifdef USE_VALUE_WithConsts 
    { MP_ROM_QSTR(MP_QSTR_CONST_INT), MP_ROM_INT(123) },
    #else
    { MP_ROM_QSTR(MP_QSTR_CONST_INT), MP_ROM_INT(CONST_INT) },
    #endif
    { MP_ROM_QSTR(MP_QSTR_CONST_NONE), MP_ROM_NONE },
    { MP_ROM_QSTR(MP_QSTR_CONST_STR), MP_ROM_PTR(&WithConsts_CONST_STR_str_obj) },
    #ifdef USE_VALUE_WithConsts 
    { MP_ROM_QSTR(MP_QSTR_CONST_TRUE), MP_ROM_TRUE },
    #else
    { MP_ROM_QSTR(MP_QSTR_CONST_TRUE), MP_ROM_INT(CONST_TRUE) },
    #endif
    { MP_ROM_QSTR(MP_QSTR_CONST_TUPLE), MP_ROM_PTR(&WithConsts_CONST_TUPLE_0_6_tuple_obj) },
};
STATIC MP_DEFINE_CONST_DICT(consts_WithConsts_locals_dict, consts_WithConsts_locals_dict_table);

// Create the class-object itself
STATIC const mp_obj_type_t consts_WithConsts_type = {
    { &mp_type_type },
    .name = MP_QSTR_WithConsts,
    .locals_dict = (mp_obj_dict_t*)&consts_WithConsts_locals_dict,
};


// module stuff
// Set up the module properties
STATIC const mp_rom_map_elem_t consts_globals_table[] = {
    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_consts) },
    { MP_ROM_QSTR(MP_QSTR_test_test), MP_ROM_PTR(&consts_test_test_obj) },
    { MP_ROM_QSTR(MP_QSTR_WithConsts), MP_ROM_PTR(&consts_WithConsts_type) },
    #define USE_VALUE   // Use VALUE from the Python stab code or NAME(aka #define NAME) from include files when this line is commented out
    #ifdef USE_VALUE  
    { MP_ROM_QSTR(MP_QSTR_CONST_FALSE), MP_ROM_FALSE },
    #else
    { MP_ROM_QSTR(MP_QSTR_CONST_FALSE), MP_ROM_INT(CONST_FALSE) },
    #endif
    { MP_ROM_QSTR(MP_QSTR_CONST_FLOAT), MP_ROM_PTR(&CONST_FLOAT_float_obj) },
    #ifdef USE_VALUE  
    { MP_ROM_QSTR(MP_QSTR_CONST_INT), MP_ROM_INT(123) },
    #else
    { MP_ROM_QSTR(MP_QSTR_CONST_INT), MP_ROM_INT(CONST_INT) },
    #endif
    { MP_ROM_QSTR(MP_QSTR_CONST_NONE), MP_ROM_NONE },
    { MP_ROM_QSTR(MP_QSTR_CONST_STR), MP_ROM_PTR(&CONST_STR_str_obj) },
    #ifdef USE_VALUE  
    { MP_ROM_QSTR(MP_QSTR_CONST_TRUE), MP_ROM_TRUE },
    #else
    { MP_ROM_QSTR(MP_QSTR_CONST_TRUE), MP_ROM_INT(CONST_TRUE) },
    #endif
    { MP_ROM_QSTR(MP_QSTR_CONST_TUPLE), MP_ROM_PTR(&CONST_TUPLE_0_6_tuple_obj) },
};
STATIC MP_DEFINE_CONST_DICT(consts_globals, consts_globals_table);

// Define the module object
const mp_obj_module_t consts_cmodule = {
    .base = { &mp_type_module },
    .globals = (mp_obj_dict_t*)&consts_globals,
};
// Register the module
MP_REGISTER_MODULE(MP_QSTR_consts, consts_cmodule, MODULE_CONSTS_ENABLED);

#endif // MODULE_CONSTS_ENABLED
