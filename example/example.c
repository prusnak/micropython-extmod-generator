/*
 * This file was generated by micropython-extmod-generator https://github.com/prusnak/micropython-extmod-generator
 * from Python stab file D:\microPython\micropython-extmod-generator\example\example.py
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2022 Module Author
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*
This is a module help.  Put it into genarated C code.
*/

#define MODULE_EXAMPLE_ENABLED (1) // you may relocate this line to the mpconfigport.h
#if MODULE_EXAMPLE_ENABLED

// Include required definitions first.
#include "py/obj.h"
#include "py/objstr.h"
#include "py/objtuple.h"
#include "py/runtime.h"
#include "py/builtin.h"

#include "objfloat.h"

    /*
    // Example exception for any generated function
    if (some_val == 0) {
        mp_raise_ValueError("'some_val' can't be zero!");
    }
    */

/*
// Module constants declarations
STATIC const MP_DEFINE_FLOAT_OBJ(CONST_FLOAT_float_obj, 4.840000000000001);
STATIC const mp_int_t CONST_INT = 2;
STATIC const void *CONST_NONE = MP_ROM_NONE;
STATIC const MP_DEFINE_STR_OBJ(CONST_STR_str_obj, "333444");

STATIC const MP_DEFINE_FLOAT_OBJ(CONST_TUPLE_0_2_float_obj, 2.2);
STATIC const MP_DEFINE_STR_OBJ(CONST_TUPLE_0_4_str_obj, "Hello, world!");
const mp_rom_obj_tuple_t CONST_TUPLE_0_4_tuple_obj = {{&mp_type_tuple}, 5, {
    MP_ROM_NONE,
    MP_ROM_INT(1),
    MP_ROM_PTR(&CONST_TUPLE_0_2_float_obj),
    MP_ROM_TRUE,
    MP_ROM_PTR(&CONST_TUPLE_0_4_str_obj),
},};

STATIC const bool *ONE_BOOL = MP_ROM_TRUE;
*/

// Defining module functions
// def func_a()
STATIC mp_obj_t example_func_a(void) {

	//TODO: Your code here

	return MP_ROM_NONE;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_0(example_func_a_obj, example_func_a);

// def func_b(arg1: int) -> None
STATIC mp_obj_t example_func_b(mp_obj_t arg1_obj) {
	mp_int_t arg1 = mp_obj_get_int(arg1_obj);


	//TODO: Your code here

	return MP_ROM_NONE;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(example_func_b_obj, example_func_b);

// def func_c(arg1: int, arg2: int) -> int
STATIC mp_obj_t example_func_c(mp_obj_t arg1_obj, mp_obj_t arg2_obj) {
	mp_int_t arg1 = mp_obj_get_int(arg1_obj);
	mp_int_t arg2 = mp_obj_get_int(arg2_obj);

	mp_int_t ret_val;

    ret_val = arg1 + arg2;

	return mp_obj_new_int(ret_val);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_2(example_func_c_obj, example_func_c);

// def func_d(arg1: bool, arg2: str, arg3: tuple) -> int
STATIC mp_obj_t example_func_d(mp_obj_t arg1_obj, mp_obj_t arg2_obj, mp_obj_t arg3_obj) {
	bool arg1 = mp_obj_is_true(arg1_obj);
	const char* arg2 = mp_obj_str_get_str(arg2_obj);
	mp_obj_t *arg3 = NULL;
	size_t arg3_len = 0;
	mp_obj_get_array(arg3_obj, &arg3_len, &arg3);

	mp_int_t ret_val;

	//TODO: Your code here

	return mp_obj_new_int(ret_val);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_3(example_func_d_obj, example_func_d);

// def func_e(arg1: list, arg2: bool, arg3: int) -> str
STATIC mp_obj_t example_func_e(mp_obj_t arg1_obj, mp_obj_t arg2_obj, mp_obj_t arg3_obj) {
	mp_obj_t *arg1 = NULL;
	size_t arg1_len = 0;
	mp_obj_get_array(arg1_obj, &arg1_len, &arg1);
	bool arg2 = mp_obj_is_true(arg2_obj);
	mp_int_t arg3 = mp_obj_get_int(arg3_obj);


	//TODO: Your code here

	// signature: mp_obj_t mp_obj_new_bytes(const char* data, size_t len);
    return mp_obj_new_str("hello", 5);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_3(example_func_e_obj, example_func_e);

// def func_f(arg1: float, arg2: int, arg3: bool, arg4: int=123) -> bytes
STATIC mp_obj_t example_func_f(size_t n_args, const mp_obj_t *args) {
	mp_float_t arg1 = mp_obj_get_float(args[0]);
	mp_int_t arg2 = mp_obj_get_int(args[1]);
	bool arg3 = mp_obj_is_true(args[2]);
	mp_int_t arg4 = mp_obj_get_int(args[3]);


	//TODO: Your code here

	// signature: mp_obj_t mp_obj_new_bytes(const byte* data, size_t len);
    return mp_obj_new_bytes("hello", 5);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(example_func_f_obj, 3, 4, example_func_f);

// def func_g() -> float
STATIC mp_obj_t example_func_g(void) {
	mp_float_t ret_val;

	//TODO: Your code here

	return mp_obj_new_float(ret_val);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_0(example_func_g_obj, example_func_g);

// def func_h() -> bool
STATIC mp_obj_t example_func_h(void) {
	bool ret_val;

	//TODO: Your code here

	return mp_obj_new_bool(ret_val);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_0(example_func_h_obj, example_func_h);

// def func_i() -> list
STATIC mp_obj_t example_func_i(void) {

	//TODO: Your code here

	// signature: mp_obj_t mp_obj_new_list(size_t n, const mp_obj_t *items);
    mp_obj_t ret_val[] = {
        mp_obj_new_int(123),
        mp_obj_new_float(456.789),
        mp_obj_new_str("hello", 5),
    };
    return mp_obj_new_list(3, ret_val);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_0(example_func_i_obj, example_func_i);

// def func_k() -> tuple
STATIC mp_obj_t example_func_k(void) {

	//TODO: Your code here

	// signature: mp_obj_t mp_obj_new_tuple(size_t n, const mp_obj_t *items);
    mp_obj_t ret_val[] = {
        mp_obj_new_int(123),
        mp_obj_new_float(456.789),
        mp_obj_new_str("hello", 5),
    };
    return mp_obj_new_tuple(3, ret_val);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_0(example_func_k_obj, example_func_k);

// Defining classes
// class Class(ParentClass, object):
/*
Class constants are supported
*/
// Class constants
STATIC const mp_int_t Class_CONST1 = 1;
STATIC const MP_DEFINE_FLOAT_OBJ(Class_CONST2_float_obj, 2.2);
STATIC const MP_DEFINE_STR_OBJ(Class_CONST3_str_obj, "333");
STATIC const mp_int_t Class_CONST_INT = 100;
STATIC const bool *Class_ONE_SHOT = MP_ROM_FALSE;
STATIC const bool *Class_PERIODIC = MP_ROM_TRUE;

STATIC const mp_obj_type_t example_Class_type;

typedef struct _mp_obj_example_Class_t {
    mp_obj_base_t base;
} mp_obj_example_Class_t;

// Defining Class methods
// def Class.__del__(self)
/*
We need destructor too 
*/
STATIC mp_obj_t example_Class___del__(mp_obj_t self_obj) {
	mp_obj_example_Class_t *self = MP_OBJ_TO_PTR(self_obj);


	//TODO: Your code here

	return MP_ROM_NONE;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(example_Class___del___obj, example_Class___del__);

// def Class.__init__(self, arg1: int, arg2: bool)
STATIC mp_obj_t example_Class_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    mp_arg_check_num(n_args, n_kw, 2, 2, false);
    mp_obj_example_Class_t *self = m_new_obj(mp_obj_example_Class_t);
    self->base.type = &example_Class_type;

/*
	mp_obj_example_Class_t *self = MP_OBJ_TO_PTR(self_obj);
	mp_int_t arg1 = mp_obj_get_int(arg1_obj);
	bool arg2 = mp_obj_is_true(arg2_obj);

*/
	//TODO: Your code here

    return MP_OBJ_FROM_PTR(self);
}

STATIC void example_Class_print(const mp_print_t *print, mp_obj_t self_obj, mp_print_kind_t kind) {
    mp_obj_example_Class_t *self = MP_OBJ_TO_PTR(self_obj);
    mp_printf(print, "Class()");

	//TODO: Your code here

}

// def Class.func_a(self)
STATIC mp_obj_t example_Class_func_a(mp_obj_t self_obj) {
	mp_obj_example_Class_t *self = MP_OBJ_TO_PTR(self_obj);


	//TODO: Your code here

	return MP_ROM_NONE;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(example_Class_func_a_obj, example_Class_func_a);

// def Class.func_b(self, arg1: str)
STATIC mp_obj_t example_Class_func_b(mp_obj_t self_obj, mp_obj_t arg1_obj) {
	mp_obj_example_Class_t *self = MP_OBJ_TO_PTR(self_obj);
	const char* arg1 = mp_obj_str_get_str(arg1_obj);


	//TODO: Your code here

	return MP_ROM_NONE;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_2(example_Class_func_b_obj, example_Class_func_b);

// def Class.func_c(self, arg1: int, arg2: float) -> None
STATIC mp_obj_t example_Class_func_c(mp_obj_t self_obj, mp_obj_t arg1_obj, mp_obj_t arg2_obj) {
	mp_obj_example_Class_t *self = MP_OBJ_TO_PTR(self_obj);
	mp_int_t arg1 = mp_obj_get_int(arg1_obj);
	mp_float_t arg2 = mp_obj_get_float(arg2_obj);


	//TODO: Your code here

	return MP_ROM_NONE;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_3(example_Class_func_c_obj, example_Class_func_c);

// def Class.func_d(self, arg1: bool, arg2: int, arg3: float) -> int
STATIC mp_obj_t example_Class_func_d(size_t n_args, const mp_obj_t *args) {
	mp_obj_example_Class_t *self = MP_OBJ_TO_PTR(args[0]);
	bool arg1 = mp_obj_is_true(args[1]);
	mp_int_t arg2 = mp_obj_get_int(args[2]);
	mp_float_t arg3 = mp_obj_get_float(args[3]);

	mp_int_t ret_val;

	//TODO: Your code here

	return mp_obj_new_int(ret_val);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(example_Class_func_d_obj, 4, 4, example_Class_func_d);

// def Class.func_e(self, arg1: str, arg2: int, arg3: int, arg4: int) -> str
STATIC mp_obj_t example_Class_func_e(size_t n_args, const mp_obj_t *args) {
	mp_obj_example_Class_t *self = MP_OBJ_TO_PTR(args[0]);
	const char* arg1 = mp_obj_str_get_str(args[1]);
	mp_int_t arg2 = mp_obj_get_int(args[2]);
	mp_int_t arg3 = mp_obj_get_int(args[3]);
	mp_int_t arg4 = mp_obj_get_int(args[4]);


	//TODO: Your code here

	// signature: mp_obj_t mp_obj_new_bytes(const char* data, size_t len);
    return mp_obj_new_str("hello", 5);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(example_Class_func_e_obj, 5, 5, example_Class_func_e);

// def Class.func_f(self, arg1: float, arg2: int, arg3: int, arg4: int, arg5: int=123) -> bytes
STATIC mp_obj_t example_Class_func_f(size_t n_args, const mp_obj_t *args) {
	mp_obj_example_Class_t *self = MP_OBJ_TO_PTR(args[0]);
	mp_float_t arg1 = mp_obj_get_float(args[1]);
	mp_int_t arg2 = mp_obj_get_int(args[2]);
	mp_int_t arg3 = mp_obj_get_int(args[3]);
	mp_int_t arg4 = mp_obj_get_int(args[4]);
	mp_int_t arg5 = mp_obj_get_int(args[5]);


	//TODO: Your code here

	// signature: mp_obj_t mp_obj_new_bytes(const byte* data, size_t len);
    return mp_obj_new_bytes("hello", 5);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(example_Class_func_f_obj, 5, 6, example_Class_func_f);

// Class stuff
// Register class methods
STATIC const mp_rom_map_elem_t example_Class_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___del__), MP_ROM_PTR(&example_Class___del___obj) },
    { MP_ROM_QSTR(MP_QSTR_func_a), MP_ROM_PTR(&example_Class_func_a_obj) },
    { MP_ROM_QSTR(MP_QSTR_func_b), MP_ROM_PTR(&example_Class_func_b_obj) },
    { MP_ROM_QSTR(MP_QSTR_func_c), MP_ROM_PTR(&example_Class_func_c_obj) },
    { MP_ROM_QSTR(MP_QSTR_func_d), MP_ROM_PTR(&example_Class_func_d_obj) },
    { MP_ROM_QSTR(MP_QSTR_func_e), MP_ROM_PTR(&example_Class_func_e_obj) },
    { MP_ROM_QSTR(MP_QSTR_func_f), MP_ROM_PTR(&example_Class_func_f_obj) },
    #define USE_VALUE_Class  // Use VALUE from the Python stab code or NAME(aka #define NAME) from include files when this line is commented out
    #ifdef USE_VALUE_Class 
    { MP_ROM_QSTR(MP_QSTR_CONST1), MP_ROM_INT(1) },
    #else
    { MP_ROM_QSTR(MP_QSTR_CONST1), MP_ROM_INT(CONST1) },
    #endif
    { MP_ROM_QSTR(MP_QSTR_CONST2), MP_ROM_PTR(&Class_CONST2_float_obj) },
    { MP_ROM_QSTR(MP_QSTR_CONST3), MP_ROM_PTR(&Class_CONST3_str_obj) },
    #ifdef USE_VALUE_Class 
    { MP_ROM_QSTR(MP_QSTR_CONST_INT), MP_ROM_INT(100) },
    #else
    { MP_ROM_QSTR(MP_QSTR_CONST_INT), MP_ROM_INT(CONST_INT) },
    #endif
    #ifdef USE_VALUE_Class 
    { MP_ROM_QSTR(MP_QSTR_ONE_SHOT), MP_ROM_FALSE },
    #else
    { MP_ROM_QSTR(MP_QSTR_ONE_SHOT), MP_ROM_INT(ONE_SHOT) },
    #endif
    #ifdef USE_VALUE_Class 
    { MP_ROM_QSTR(MP_QSTR_PERIODIC), MP_ROM_TRUE },
    #else
    { MP_ROM_QSTR(MP_QSTR_PERIODIC), MP_ROM_INT(PERIODIC) },
    #endif
};
STATIC MP_DEFINE_CONST_DICT(example_Class_locals_dict, example_Class_locals_dict_table);

// Create the class-object itself
STATIC const mp_obj_type_t example_Class_type = {
    { &mp_type_type },
    .name = MP_QSTR_Class,
    .make_new = example_Class_make_new,
    //.print = example_Class_print,
    .locals_dict = (mp_obj_dict_t*)&example_Class_locals_dict,
};

// class ParentClass(object):
// ParentClass constants
STATIC const mp_int_t ParentClass_CONST_INT = 100;

STATIC const mp_obj_type_t example_ParentClass_type;

typedef struct _mp_obj_example_ParentClass_t {
    mp_obj_base_t base;
} mp_obj_example_ParentClass_t;

// ParentClass stuff
// Register class methods
STATIC const mp_rom_map_elem_t example_ParentClass_locals_dict_table[] = {
    #define USE_VALUE_ParentClass  // Use VALUE from the Python stab code or NAME(aka #define NAME) from include files when this line is commented out
    #ifdef USE_VALUE_ParentClass 
    { MP_ROM_QSTR(MP_QSTR_CONST_INT), MP_ROM_INT(100) },
    #else
    { MP_ROM_QSTR(MP_QSTR_CONST_INT), MP_ROM_INT(CONST_INT) },
    #endif
};
STATIC MP_DEFINE_CONST_DICT(example_ParentClass_locals_dict, example_ParentClass_locals_dict_table);

// Create the class-object itself
STATIC const mp_obj_type_t example_ParentClass_type = {
    { &mp_type_type },
    .name = MP_QSTR_ParentClass,
    .locals_dict = (mp_obj_dict_t*)&example_ParentClass_locals_dict,
};


// module stuff
// Set up the module properties
STATIC const mp_rom_map_elem_t example_globals_table[] = {
    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_example) },
    { MP_ROM_QSTR(MP_QSTR_func_a), MP_ROM_PTR(&example_func_a_obj) },
    { MP_ROM_QSTR(MP_QSTR_func_b), MP_ROM_PTR(&example_func_b_obj) },
    { MP_ROM_QSTR(MP_QSTR_func_c), MP_ROM_PTR(&example_func_c_obj) },
    { MP_ROM_QSTR(MP_QSTR_func_d), MP_ROM_PTR(&example_func_d_obj) },
    { MP_ROM_QSTR(MP_QSTR_func_e), MP_ROM_PTR(&example_func_e_obj) },
    { MP_ROM_QSTR(MP_QSTR_func_f), MP_ROM_PTR(&example_func_f_obj) },
    { MP_ROM_QSTR(MP_QSTR_func_g), MP_ROM_PTR(&example_func_g_obj) },
    { MP_ROM_QSTR(MP_QSTR_func_h), MP_ROM_PTR(&example_func_h_obj) },
    { MP_ROM_QSTR(MP_QSTR_func_i), MP_ROM_PTR(&example_func_i_obj) },
    { MP_ROM_QSTR(MP_QSTR_func_k), MP_ROM_PTR(&example_func_k_obj) },
    { MP_ROM_QSTR(MP_QSTR_Class), MP_ROM_PTR(&example_Class_type) },
    { MP_ROM_QSTR(MP_QSTR_ParentClass), MP_ROM_PTR(&example_ParentClass_type) },
    #define USE_VALUE   // Use VALUE from the Python stab code or NAME(aka #define NAME) from include files when this line is commented out
    { MP_ROM_QSTR(MP_QSTR_CONST_FLOAT), MP_ROM_PTR(&CONST_FLOAT_float_obj) },
    #ifdef USE_VALUE  
    { MP_ROM_QSTR(MP_QSTR_CONST_INT), MP_ROM_INT(2) },
    #else
    { MP_ROM_QSTR(MP_QSTR_CONST_INT), MP_ROM_INT(CONST_INT) },
    #endif
    { MP_ROM_QSTR(MP_QSTR_CONST_NONE), MP_ROM_NONE },
    { MP_ROM_QSTR(MP_QSTR_CONST_STR), MP_ROM_PTR(&CONST_STR_str_obj) },
    { MP_ROM_QSTR(MP_QSTR_CONST_TUPLE), MP_ROM_PTR(&CONST_TUPLE_0_4_tuple_obj) },
    #ifdef USE_VALUE  
    { MP_ROM_QSTR(MP_QSTR_ONE_BOOL), MP_ROM_TRUE },
    #else
    { MP_ROM_QSTR(MP_QSTR_ONE_BOOL), MP_ROM_INT(ONE_BOOL) },
    #endif
};
STATIC MP_DEFINE_CONST_DICT(example_globals, example_globals_table);

// Define the module object
const mp_obj_module_t example_cmodule = {
    .base = { &mp_type_module },
    .globals = (mp_obj_dict_t*)&example_globals,
};
// Register the module
MP_REGISTER_MODULE(MP_QSTR_example, example_cmodule, MODULE_EXAMPLE_ENABLED);

#endif // MODULE_EXAMPLE_ENABLED
